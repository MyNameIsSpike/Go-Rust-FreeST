\documentclass[runningheads]{llncs}

%PACKAGES
\usepackage[utf8]{inputenc}
\usepackage{listings, xcolor}
\usepackage{graphicx} 
\usepackage{lipsum}
\usepackage{float}
\setcounter{secnumdepth}{5}
\begin{document}
\title{Comparing FreeST, Go and Rust}
\author{Jorge Martins\inst{1} \and
Diogo Lopes\inst{1}
}
\definecolor{darkblue}{rgb}{0.0, 0.0, 0.55}
\lstset{language=Java,
numbers=none,
keywordstyle = \color{blue},
commentstyle = \color{darkblue},
breaklines = true,
showstringspaces = false,
tabsize = 4,
basicstyle=\small,
} 
\institute{Departamento de Informática da Faculdade de Ciências da Universidade de Lisboa
\email{\{fc51033,fc51058\}@alunos.fc.ul.pt}}
\nocite{*}
\maketitle
\thispagestyle{empty}
\begin{abstract}
FreeST is an experimental functional programming language being developed at LASIGE that offers primitives to thread creation and channel communication, different to those in programming languages such as Go and Rust, that are currently being appraised by their performance and reliability. Despite being different, these languages can be compared by the characteristics of their common primitives and by their learning curve. Although there are several articles comparing Rust and Go, they mainly focus in performance and reliability instead of the learning curve of each language and their approach to channel communication and thread creation. FreeST on the other hand, due to the small community working on it, is yet to be compared to the others.
In order to compare the three languages we used an algorithm that focuses on thread creation, communication using channels and thread synchronization using those same channels. To implement this algorithm we learned the three languages so that we could comment on the difficulties and different aspects of each.
This comparison is useful to understand what aspects of some languages could benefit the others and also to inform about what difficulties developers may find when writing code in each of them.
\keywords{FreeST \and Rust \and Go.}
\end{abstract}
\section{Introduction}
Rust and Go are languages that are growing in popularity due to their performance and reliability, according to the TIOBE index, and FreeST\cite{freest} on the other hand is a very recent programming language that is still being developed at LASIGE, a research center in the Faculty of Sciences of the University of Lisbon. 
In order to compare these three languages, that were completely new to each of us until the start of this project, we aimed to understand the basic concepts of each one, such as the ownership and lifetimes in Rust or the session types \cite{session} in FreeST.
When starting to learn a new language we need to understand how the basics of that language work, and therefore our initial focus was to learn those basic concepts in each language. Once we had a clear view of this concepts we focused on the concurrency primitives of these programming languages since in this project we mainly aimed to show the differences between how each one of them handles concurrency and channels communication.
To see this differences in action we used a simple algorithm simulating a communication between a customer and an travel agency that would eventually spawn a service to finish a transaction. This way we could see in action the creation of threads, since each of these entities will run in a different thread. This algorithm also allows to see how channel communication functions in each programming language because these threads use channels as a form of communication. Finally we can see how these channels can offer thread synchronization as well.
Our goal was to implement this algorithm in Rust, Go and FreeST, in order to understand the main differences and characteristics of each language and identifying the main complications we had while learning them.
\section{Background}
\subsection{The Plane Ticket Algorithm}
In order to explore the interprocess communication through channels and thread creation, we used a simple algorithm that simulates a customer trying to buy a plane ticket from an agency, that can eventually create a service to finish the transaction with the customer. The customer, the agency and the service will be executed in different threads and will communicate through rendezvous channels, meaning 
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{Algorithm.png}
\caption{Plane Ticket Algorithm System Sequence Diagram}
\label{ssd}
\end{figure}
As we can see in figure \ref{ssd} the algorithm consists in an early stage of negotiation where a customer will send a journey preference(e.g. "Rome") to the agency and receive the price for a ticket to the given preference repeatedly until evalOffer evaluates to true.
At this point the customer will make a choice:
\begin{itemize}
\item If the received price is lower or equal to the max accepted price of the customer, he will accept the offer.
The agency will spawn a service which will receive the customer address and send the journey date.
\item If the received price is greater than the max accepted price of the customer, he will reject the offer and end the communication.
\end{itemize}
The pseudo code for this algorithm is as follow:
\begin{lstlisting}[caption={Customer Algorithm},captionpos=b]
class Customer {
	Address addr;
	double price, maxPrice;
	bool loop := true;
	String journeyPref;
	new Agency.sell {
		sendWhile (loop) {
			send( journeyPref );
			price := receive;
			loop := evalOffer(journeyPref,price);
			// implementation of evalOffer omitted
		};
		sendCase( evalPrice(price,maxPrice) ) {
			ACCEPT > send( addr ); Date date := receive;
			REJECT > null; /* customer rejects price
					,end of protocol */ 
		}
	} /* End method invocation */
}
\end{lstlisting}
\begin{lstlisting}[caption={Agency Algorithm},captionpos=b]
class Agency {
	String journeyPref;
	void acceptOrder sell {
		receiveWhile {
			journeyPref := receive;
			double price := getPrice( journeyPref );
			// implementation of getPrice omitted
			send( price );
		}
		receiveCase (x) { // buyer accepts price
			ACCEPT < new Service . orderDelivery { } ,
			REJECT < null;// receiveCase : buyer rejects 
        }
	} /* End method sell */
}
\end{lstlisting}
\begin{lstlisting}[caption={Service Algorithm},captionpos=b]
class Service {
	void receiveOrderSession orderDelivery() {
		Address custAddress := receive;
		Date date := new Date();
		send( date );
	}
}
\end{lstlisting}
\subsection{Programming Languages}
\subsubsection{Rust}\hfill\\\\
\subsubsection{Go}\hfill\\\\
Go is a programming language designed at Google that focuses in performance, usability and parallel programming.
Its statically typed, meaning it checks the type safety of the program by analysing the source code. Therefore we know at compilation time what errors we might have committed.\\
It introduces a new primitive called Goroutines, a form of lightweight threads, meaning they share context with other goroutines in a program. They are also managed by the Go runtime, that will be responsible for the scheduling of each goroutine. This means that if one goroutine is blocked, Go's run-time will switch to another with work to do.
Goroutines multiplex coroutines, independently executing functions, onto a set of thread that by default match the number of logical processors of the environment. Of course this can be change with the {\it GOMAXPROCS} function that sets the number of logical processes that the go program can access. Another great aspect of goroutines is that they achieve all this we a very modest amount of memory, allowing the execution of a great number of them.\\
Go treats channels are first class objects, in contrast with most of the other languages that offer them through external packages, or crates as we will see in Rust. This channels allow goroutines to communicate between themselves and it also allows to synchronize this same goroutines, because the channels block until the sender/receiver are ready to continue.\\	
Go was also built to be simple to understand, and because of that its syntax is very easy to learn. We can observe this in goroutines that can be started with a simple:
\begin{lstlisting}[language=Go]
go func()
\end{lstlisting} 
or the channels, constructed with
\begin{lstlisting}[language=Go]
c := make(chan string)
\end{lstlisting}.
This language also encourages developers to write good code, emitting warnings to bad practices such as unused variables or unused imports, keeping the code clean.
\subsubsection{FreeST}\hfill\\\\
FreeST is a programming language developed at LASIGE, that focus on thread creation and channel communication. Its syntax is very similar to Haskell and it introduces a very powerful tool: context-free session types based channels.\\
Session types describe communications in heterogeneous channels with a tail recursive structure.
For example we can describe a channel that sends a String and receives a Int in a very simple way
\begin{lstlisting}[language=haskell]
type exampleC : SL = !String;?Int
\end{lstlisting}
This allows a programmer to send different types in a channel without having to wrap it in a new type structure.
It also allows to use {\it Choices}, in order for the thread to choose which communication path it will follow:
\begin{lstlisting}[language=haskell]
type exampleC : SL = +{ChoiceOne: !String;?Int, ChoiceTwo: !String;?String}
\end{lstlisting}
This is achieved by the select keyword that, as the name indicates, selects the desired branch. The other end of the communication will then learn which choice was made by matching the channel with one of the many choice it is allowed to make.
The {\it send} and {\it receive} functions send a message through a given channel and receive a message from a given channel, respectively, returning, in the end, whatever is left for that channel to do. This means, for example, that once we send a String in the channel above (!String;?Int) we will then receive a channel of type ?Int, since the !String part was consumed by the {\it send} function. Once there is nothing else for a channel to do they return the previously mentioned skip.
Another concept to have in mind when using FreeST is the notion of Kind, that divides types into 4 categories, as we can see in figure \ref{kind}.
\begin{figure}[H]
\centering
\includegraphics[scale=1]{kind.png}
\caption{FreeST Kinding System}
\label{kind}
\end{figure}
These types are organized into their prekinds, functional(T) or session(S), and their multiplicity, linear(L) or unrestricted(U).
The channels we mentioned above are of type SL, meaning they are linear session types. This means they must be fully consumed once created, or otherwise the compiler will emit an error.
Similiar to Go and Rust these channel are blocking, allowing us to synchronize the threads by simply waiting for and sending messages.
Another relevant aspect is the fork primitive, that allows the programmer to create threads by using the forkIO primitive.
FreeST is in its early stages of development, recently released v1.0.3, meaning there are still a lot of primitives that one usually finds in programming languages missing, such as floats and randoms.
\section{Implementation Details}
\lipsum[1]
\subsection{Go}
\lipsum[1]
\subsection{Rust}
\lipsum[1]
\subsection{FreeST}
\lipsum[1]
\subsection{Discussion}
Here you should discuss the results on a high level. For instance, based on our results, the parallelization of the merge-sort is relevant as no other parallel work occurs at the same time, and the complexity $O(N log(N))$ can have a large impact when the number of individuals is high.
\section{Conclusions}
Here you should resume the major conclusions taken from discussion. Ideally, these should align with the objectives introduced in the introduction.


You should also list the future work, i. e., tasks and challenges that were outside your scope, but are relevant.
\section*{Acknowledgements}
First Author wrote the part of the program implemented the phasers. Second Author implemented the MergeSort in parallel. 

Both authors wrote this paper, with First Author focusing on the introduction, related work and conclusions while the Second Author focused on approach and evaluation.

Each author spent around 30 hours on this project.

\textcolor{red}{Jorge Martins implemented the algorithm in Rust and Go. Both authors implemented the algorithm in FreeST.
Both authors wrote this paper, ... 
Jorge Martins spent around X hours on this project. Diogo Lopes spent around Y hours on this project.}
\bibliographystyle{unsrt}
\bibliography{bibliography}
\end{document}